using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System.ComponentModel.DataAnnotations;
using System.Security.Cryptography;
using System.Text;
using HIS.APP.Data;
using HIS.APP.Models;

namespace HIS.APP.Controllers
{
    [ApiController]
    [Route("[controller]")]
    public sealed class ReportController : Controller
    {
        private readonly ApplicationDbContext _db;
        private readonly ILogger<ReportController> _logger;

        public ReportController(ApplicationDbContext db, ILogger<ReportController> logger)
        {
            _db = db ?? throw new ArgumentNullException(nameof(db));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        // -------- Query DTO (validated) --------
        public sealed class ReportQuery
        {
            /// <summary>Search text (title/description contains, case-insensitive)</summary>
            [MaxLength(200)]
            public string? Q { get; init; }

            /// <summary>createdAt|title|status (default: createdAt)</summary>
            [RegularExpression("^(createdAt|title|status)$", ErrorMessage = "Invalid sortBy")]
            public string SortBy { get; init; } = "createdAt";

            /// <summary>asc|desc (default: desc)</summary>
            [RegularExpression("^(asc|desc)$", ErrorMessage = "Invalid dir")]
            public string Dir { get; init; } = "desc";

            /// <summary>1-based page (default: 1)</summary>
            [Range(1, int.MaxValue)]
            public int Page { get; init; } = 1;

            /// <summary>items per page (default: 20, max: 100)</summary>
            [Range(1, 100)]
            public int PageSize { get; init; } = 20;

            /// <summary>Include total count (costly on very large tables). Default: true</summary>
            public bool IncludeTotal { get; init; } = true;
        }

        public sealed record ReportListItemVm(
            int Id,
            string Title,
            string Status,
            DateTime CreatedAt
        );

        public sealed record ReportDetailsVm(
            int Id,
            string Title,
            string? Description,
            string Status,
            DateTime CreatedAt,
            DateTime? UpdatedAt
        );

        public sealed record PagedResult<T>(
            IReadOnlyList<T> Items,
            int? Total,                // null when IncludeTotal=false
            int Page,
            int PageSize,
            bool HasPrevious,
            bool HasNext
        )
        {
            public int? TotalPages =>
                Total.HasValue ? (int)Math.Ceiling((double)Total.Value / PageSize) : null;
        }

        // -------- List (Index) --------
        /// <summary>
        /// Paginated, sortable, filterable list of reports (read-only).
        /// </summary>
        [HttpGet("")]
        [ProducesResponseType(typeof(PagedResult<ReportListItemVm>), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ResponseCache(Duration = 60, VaryByQueryKeys = new[] { "q", "sortBy", "dir", "page", "pageSize", "includeTotal" })]
        public async Task<IActionResult> Index([FromQuery] ReportQuery query, CancellationToken ct = default)
        {
            if (!ModelState.IsValid)
                return ValidationProblem(ModelState);

            using var scope = _logger.BeginScope(new
            {
                TraceId = HttpContext.TraceIdentifier,
                query.Q,
                query.SortBy,
                query.Dir,
                query.Page,
                query.PageSize,
                query.IncludeTotal
            });

            try
            {
                IQueryable<Report> q = _db.Reports.AsNoTracking();

                // Search (case-insensitive, SQL-optimized)
                if (!string.IsNullOrWhiteSpace(query.Q))
                {
                    var term = $"%{EscapeLike(query.Q.Trim())}%";
                    q = q.Where(r =>
                        EF.Functions.Like(r.Title, term) ||
                        (r.Description != null && EF.Functions.Like(r.Description, term)));
                }

                // Sorting (whitelist â†’ selector + direction)
                q = ApplySort(q, query.SortBy, query.Dir);

                // For ETag/Last-Modified: get the most recent CreatedAt for the current filter (cheap with index)
                var lastCreatedAtTask = q.Select(r => r.CreatedAt).OrderByDescending(d => d).FirstOrDefaultAsync(ct);

                // Paging
                var skip = (query.Page - 1) * query.PageSize;

                var pageItemsTask = q
                    .Skip(skip)
                    .Take(query.PageSize)
                    .Select(r => new ReportListItemVm(r.Id, r.Title, r.Status, r.CreatedAt))
                    .ToListAsync(ct);

                int? total = null;
                Task<int>? totalTask = null;
                if (query.IncludeTotal)
                    totalTask = q.CountAsync(ct);

                await Task.WhenAll(pageItemsTask, lastCreatedAtTask, totalTask ?? Task.CompletedTask);

                if (query.IncludeTotal)
                    total = totalTask!.Result;

                var items = pageItemsTask.Result;
                var hasPrevious = query.Page > 1;
                var hasNext = query.IncludeTotal
                    ? (skip + items.Count) < total
                    : items.Count == query.PageSize; // heuristic when total omitted

                // HTTP caching (ETag + Last-Modified)
                var lastCreatedAt = lastCreatedAtTask.Result;
                var etag = ComputeEtag(items, total, query);
                if (AddConditionalCacheHeaders(etag, lastCreatedAt))
                    return StatusCode(StatusCodes.Status304NotModified);

                var result = new PagedResult<ReportListItemVm>(
                    Items: items,
                    Total: total,
                    Page: query.Page,
                    PageSize: query.PageSize,
                    HasPrevious: hasPrevious,
                    HasNext: hasNext
                );

                return Ok(result);
            }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("Index was cancelled by the client.");
                return StatusCode(499); // Client Closed Request
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving reports.");
                return Problem(statusCode: 500, title: "Error retrieving reports");
            }
        }

        // -------- Details --------
        /// <summary>Retrieves a specific report by ID (read-only).</summary>
        [HttpGet("{id:int}")]
        [ProducesResponseType(typeof(ReportDetailsVm), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<IActionResult> Details([FromRoute] int id, CancellationToken ct)
        {
            using var scope = _logger.BeginScope(new { TraceId = HttpContext.TraceIdentifier, ReportId = id });

            try
            {
                var vm = await _db.Reports
                    .AsNoTracking()
                    .Where(r => r.Id == id)
                    .Select(r => new ReportDetailsVm(
                        r.Id,
                        r.Title,
                        r.Description,
                        r.Status,
                        r.CreatedAt,
                        r.UpdatedAt
                    ))
                    .FirstOrDefaultAsync(ct);

                if (vm is null)
                {
                    _logger.LogInformation("Report {ReportId} not found.", id);
                    return NotFound();
                }

                // Conditional cache for Details by UpdatedAt
                var lastModified = vm.UpdatedAt ?? vm.CreatedAt;
                var etag = ComputeEtag(vm);
                if (AddConditionalCacheHeaders(etag, lastModified))
                    return StatusCode(StatusCodes.Status304NotModified);

                return Ok(vm);
            }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("Details({ReportId}) was cancelled by the client.", id);
                return StatusCode(499);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving report {ReportId}.", id);
                return Problem(statusCode: 500, title: "Error retrieving report");
            }
        }

        // -------- Helpers --------

        private static string EscapeLike(string input)
        {
            // escape % and _ for LIKE
            return input.Replace("\\", "\\\\").Replace("%", "\\%").Replace("_", "\\_");
        }

        private static IQueryable<Report> ApplySort(IQueryable<Report> q, string sortBy, string dir)
        {
            var asc = dir.Equals("asc", StringComparison.OrdinalIgnoreCase);

            return sortBy switch
            {
                "title"     => asc ? q.OrderBy(r => r.Title)     : q.OrderByDescending(r => r.Title),
                "status"    => asc ? q.OrderBy(r => r.Status)    : q.OrderByDescending(r => r.Status),
                // default createdAt
                _           => asc ? q.OrderBy(r => r.CreatedAt) : q.OrderByDescending(r => r.CreatedAt),
            };
        }

        private static string ComputeEtag(object data)
        {
            var json = System.Text.Json.JsonSerializer.Serialize(data);
            using var sha = SHA256.Create();
            var hash = sha.ComputeHash(Encoding.UTF8.GetBytes(json));
            return "\"" + Convert.ToHexString(hash) + "\"";
        }

        private bool AddConditionalCacheHeaders(string etag, DateTime? lastModifiedUtc)
        {
            if (lastModifiedUtc.HasValue)
                Response.Headers["Last-Modified"] = lastModifiedUtc.Value.ToUniversalTime().ToString("R");

            Response.Headers["ETag"] = etag;

            var inm = Request.Headers.IfNoneMatch.ToString();
            var ims = Request.Headers.IfModifiedSince.ToString();

            var etagMatch = !string.IsNullOrEmpty(inm) && inm.Split(',').Select(s => s.Trim()).Contains(etag);
            var timeMatch = DateTime.TryParse(ims, out var since)
                            && lastModifiedUtc.HasValue
                            && lastModifiedUtc.Value.ToUniversalTime() <= since.ToUniversalTime();

            return etagMatch || timeMatch;
        }
    }
}
